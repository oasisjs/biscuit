import type { Session, Snowflake } from './deps';
export declare class Collection<V> extends Map<Snowflake, V> {
    constructor(session: Session, entries?: Iterable<readonly [Snowflake, V]>);
    readonly session: Session;
    get(key: Snowflake): V | undefined;
    set(key: Snowflake, value: V): this;
    has(key: Snowflake): boolean;
    clear(): void;
    random(): V | undefined;
    random(amount: number): V[];
    find(fn: (value: V, key: Snowflake, structCache: this) => boolean): V | undefined;
    filter(fn: (value: V, key: Snowflake, structCache: this) => boolean): Collection<V>;
    forEach<T>(fn: (value: V, key: Snowflake, structCache: this) => T): void;
    clone(): Collection<V>;
    concat(structures: Collection<V>[]): Collection<V>;
    some(fn: (value: V, key: Snowflake, structCache: this) => boolean): boolean;
    every(fn: (value: V, key: Snowflake, structCache: this) => boolean): boolean;
    first(): V | undefined;
    first(amount: number): V[];
    last(): V | undefined;
    last(amount: number): V[];
    reverse(): this;
    map<T>(fn: (value: V, key: Snowflake, collection: this) => T): T[];
    reduce<T>(fn: (acc: T, value: V, key: Snowflake, structCache: this) => T, initV?: T): T;
    get size(): number;
    get empty(): boolean;
    updateFields(key: Snowflake, obj: Partial<V>): this | undefined;
    getOr(key: Snowflake, or: V): V | undefined;
    retrieve<T>(key: Snowflake, fn: (value: V) => T): T | undefined;
}
export default Collection;
