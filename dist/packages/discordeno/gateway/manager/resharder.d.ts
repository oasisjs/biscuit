import { GatewayBot } from '../../types/shared';
import { GatewayManager } from './gatewayManager';
export declare type Resharder = ReturnType<typeof activateResharder>;
export declare function activateResharder(options: ActivateResharderOptions): {
    /** Interval in milliseconds of when to check whether it's time to reshard.
     *
     * @default 28800000 (8 hours)
     */
    checkInterval: number;
    /** Gateway manager which is currently processing all shards and events. */
    gateway: {
        buckets: Map<number, {
            workers: {
                id: number;
                queue: number[];
            }[];
            leak: import("../../util/bucket").LeakyBucket; /** The percentage at which resharding should occur.
            //       *
            //       * @default 80
            //       */
        }>;
        firstShardId: number;
        gatewayBot: import("../../mod").GatewayBot;
        lastShardId: number;
        manager: {
            createShardOptions: {
                /** Activate the resharder and delay the next reshard check. */
                events: {
                    message: (shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }, payload: import("../../mod").DiscordGatewayPayload) => unknown;
                    heartbeat?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    heartbeatAck?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    hello?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    invalidSession?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }, resumable: boolean) => unknown) | undefined;
                    resuming?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    resumed?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    requestedReconnect?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    connecting?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    connected?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    disconnected?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    identifying?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    identified?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                };
                resolves?: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void> | undefined;
                calculateSafeRequests?: typeof import("../mod").calculateSafeRequests | undefined;
                close?: typeof import("../mod").close | undefined;
                connect?: typeof import("../mod").connect | undefined;
                handleClose?: typeof import("../mod").handleClose | undefined;
                handleMessage?: typeof import("../mod").handleMessage | undefined;
                identify?: typeof import("../mod").identify | undefined;
                isOpen?: typeof import("../mod").isOpen | undefined;
                makePresence?: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                maxRequestsPerRateLimitTick?: number | undefined;
                previousSequenceNumber?: number | undefined;
                rateLimitResetInterval?: number | undefined;
                resume?: typeof import("../mod").resume | undefined;
                send?: typeof import("../mod").send | undefined;
                shutdown?: typeof import("../mod").shutdown | undefined;
                startHeartbeating?: typeof import("../mod").startHeartbeating | undefined;
                state?: import("../mod").ShardState | undefined;
                stopHeartbeating?: typeof import("../mod").stopHeartbeating | undefined;
                heart?: import("../mod").ShardHeart | undefined;
                bucket?: import("../../util/bucket").LeakyBucket | undefined;
                offlineSendQueue?: import("../mod").ShardSocketRequest[] | undefined;
            };
            gatewayConfig: import("../../mod").PickPartial<import("../mod").ShardGatewayConfig, "token">;
            shards: Map<number, {
                gatewayConfig: import("../mod").ShardGatewayConfig;
                heart: import("../mod").ShardHeart;
                id: number;
                maxRequestsPerRateLimitTick: number;
                previousSequenceNumber: number | null;
                rateLimitResetInterval: number;
                sessionId: string | undefined;
                socket: WebSocket | undefined;
                state: import("../mod").ShardState;
                totalShards: number;
                events: import("../mod").ShardEvents;
                calculateSafeRequests: () => number;
                close: (code: number, reason: string) => void;
                connect: () => Promise<void>;
                identify: () => Promise<void>;
                isOpen: () => boolean;
                makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                resume: () => Promise<void>;
                send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                shutdown: () => Promise<void>;
                bucket: import("../../util/bucket").LeakyBucket;
                handleClose: (close: CloseEvent) => Promise<void>;
                handleMessage: (message: MessageEvent<any>) => Promise<void>;
                requestIdentify: () => Promise<void>;
                offlineSendQueue: ((_?: unknown) => void)[];
                resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                startHeartbeating: (interval: number) => void;
                stopHeartbeating: () => void;
            }>;
            totalShards: number;
            identify: (shardId: number) => Promise<void>;
            kill: (shardId: number) => Promise<void>; /** Interval in milliseconds of when to check whether it's time to reshard.
             *
             * @default 28800000 (8 hours)
             */
            requestIdentify: (shardId: number) => Promise<void>;
        };
        spawnShardDelay: number;
        shardsPerWorker: number;
        totalWorkers: number;
        prepareBuckets: () => void;
        spawnShards: () => void;
        stop: (code: number, reason: string) => Promise<void>;
        tellWorkerToIdentify: (workerId: number, shardId: number, bucketId: number) => Promise<void>;
        debug: (text: import("./gatewayManager").GatewayDebugEvents, ...args: any[]) => unknown;
        calculateTotalShards: () => number;
        calculateWorkerId: (shardId: number) => number;
    };
    /** Timeout of the reshard checker. */
    intervalId: number | undefined;
    /** Percentage at which resharding should occur.
     * @default 80
     */
    percentage: number;
    /** Whether the resharder should automatically switch to LARGE BOT SHARDING when the bot is above 100K servers. */
    useOptimalLargeBotSharding: boolean;
    /** Activate the resharder and delay the next reshard check. */
    activate: () => void;
    /** Function which is used to fetch the current gateway information of the bot.
     * This function is mainly used by the reshard checker.
     */
    getGatewayBot: () => Promise<GatewayBot>;
    /** Reshard the bots gateway. */
    reshard: (gatewayBot: GatewayBot) => Promise<{
        buckets: Map<number, {
            workers: {
                id: number;
                queue: number[];
            }[];
            leak: import("../../util/bucket").LeakyBucket; /** The percentage at which resharding should occur.
            //       *
            //       * @default 80
            //       */
        }>;
        firstShardId: number;
        gatewayBot: import("../../mod").GatewayBot;
        lastShardId: number;
        manager: {
            createShardOptions: {
                /** Activate the resharder and delay the next reshard check. */
                events: {
                    message: (shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }, payload: import("../../mod").DiscordGatewayPayload) => unknown;
                    heartbeat?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    heartbeatAck?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    hello?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    invalidSession?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }, resumable: boolean) => unknown) | undefined;
                    resuming?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    resumed?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    requestedReconnect?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    connecting?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    connected?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    disconnected?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    identifying?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    identified?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                };
                resolves?: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void> | undefined;
                calculateSafeRequests?: typeof import("../mod").calculateSafeRequests | undefined;
                close?: typeof import("../mod").close | undefined;
                connect?: typeof import("../mod").connect | undefined;
                handleClose?: typeof import("../mod").handleClose | undefined;
                handleMessage?: typeof import("../mod").handleMessage | undefined;
                identify?: typeof import("../mod").identify | undefined;
                isOpen?: typeof import("../mod").isOpen | undefined;
                makePresence?: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                maxRequestsPerRateLimitTick?: number | undefined;
                previousSequenceNumber?: number | undefined;
                rateLimitResetInterval?: number | undefined;
                resume?: typeof import("../mod").resume | undefined;
                send?: typeof import("../mod").send | undefined;
                shutdown?: typeof import("../mod").shutdown | undefined;
                startHeartbeating?: typeof import("../mod").startHeartbeating | undefined;
                state?: import("../mod").ShardState | undefined;
                stopHeartbeating?: typeof import("../mod").stopHeartbeating | undefined;
                heart?: import("../mod").ShardHeart | undefined;
                bucket?: import("../../util/bucket").LeakyBucket | undefined;
                offlineSendQueue?: import("../mod").ShardSocketRequest[] | undefined;
            };
            gatewayConfig: import("../../mod").PickPartial<import("../mod").ShardGatewayConfig, "token">;
            shards: Map<number, {
                gatewayConfig: import("../mod").ShardGatewayConfig;
                heart: import("../mod").ShardHeart;
                id: number;
                maxRequestsPerRateLimitTick: number;
                previousSequenceNumber: number | null;
                rateLimitResetInterval: number;
                sessionId: string | undefined;
                socket: WebSocket | undefined;
                state: import("../mod").ShardState;
                totalShards: number;
                events: import("../mod").ShardEvents;
                calculateSafeRequests: () => number;
                close: (code: number, reason: string) => void;
                connect: () => Promise<void>;
                identify: () => Promise<void>;
                isOpen: () => boolean;
                makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                resume: () => Promise<void>;
                send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                shutdown: () => Promise<void>;
                bucket: import("../../util/bucket").LeakyBucket;
                handleClose: (close: CloseEvent) => Promise<void>;
                handleMessage: (message: MessageEvent<any>) => Promise<void>;
                requestIdentify: () => Promise<void>;
                offlineSendQueue: ((_?: unknown) => void)[];
                resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                startHeartbeating: (interval: number) => void;
                stopHeartbeating: () => void;
            }>;
            totalShards: number;
            identify: (shardId: number) => Promise<void>;
            kill: (shardId: number) => Promise<void>; /** Interval in milliseconds of when to check whether it's time to reshard.
             *
             * @default 28800000 (8 hours)
             */
            requestIdentify: (shardId: number) => Promise<void>;
        };
        spawnShardDelay: number;
        shardsPerWorker: number;
        totalWorkers: number;
        prepareBuckets: () => void;
        spawnShards: () => void;
        stop: (code: number, reason: string) => Promise<void>;
        tellWorkerToIdentify: (workerId: number, shardId: number, bucketId: number) => Promise<void>;
        debug: (text: import("./gatewayManager").GatewayDebugEvents, ...args: any[]) => unknown;
        calculateTotalShards: () => number;
        calculateWorkerId: (shardId: number) => number;
    }>;
    tellWorkerToPrepare: (gatewayManager: {
        buckets: Map<number, {
            workers: {
                id: number;
                queue: number[];
            }[];
            leak: import("../../util/bucket").LeakyBucket; /** The percentage at which resharding should occur.
            //       *
            //       * @default 80
            //       */
        }>;
        firstShardId: number;
        gatewayBot: import("../../mod").GatewayBot;
        lastShardId: number;
        manager: {
            createShardOptions: {
                /** Activate the resharder and delay the next reshard check. */
                events: {
                    message: (shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }, payload: import("../../mod").DiscordGatewayPayload) => unknown;
                    heartbeat?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    heartbeatAck?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    hello?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    invalidSession?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }, resumable: boolean) => unknown) | undefined;
                    resuming?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    resumed?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    requestedReconnect?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    connecting?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    connected?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    disconnected?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    identifying?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                    identified?: ((shard: {
                        gatewayConfig: import("../mod").ShardGatewayConfig;
                        heart: import("../mod").ShardHeart;
                        id: number;
                        maxRequestsPerRateLimitTick: number;
                        previousSequenceNumber: number | null;
                        rateLimitResetInterval: number;
                        sessionId: string | undefined;
                        socket: WebSocket | undefined;
                        state: import("../mod").ShardState;
                        totalShards: number;
                        events: import("../mod").ShardEvents;
                        calculateSafeRequests: () => number;
                        close: (code: number, reason: string) => void;
                        connect: () => Promise<void>;
                        identify: () => Promise<void>;
                        isOpen: () => boolean;
                        makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                        resume: () => Promise<void>;
                        send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                        shutdown: () => Promise<void>;
                        bucket: import("../../util/bucket").LeakyBucket;
                        handleClose: (close: CloseEvent) => Promise<void>;
                        handleMessage: (message: MessageEvent<any>) => Promise<void>;
                        requestIdentify: () => Promise<void>;
                        offlineSendQueue: ((_?: unknown) => void)[];
                        resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                        startHeartbeating: (interval: number) => void;
                        stopHeartbeating: () => void;
                    }) => unknown) | undefined;
                };
                resolves?: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void> | undefined;
                calculateSafeRequests?: typeof import("../mod").calculateSafeRequests | undefined;
                close?: typeof import("../mod").close | undefined;
                connect?: typeof import("../mod").connect | undefined;
                handleClose?: typeof import("../mod").handleClose | undefined;
                handleMessage?: typeof import("../mod").handleMessage | undefined;
                identify?: typeof import("../mod").identify | undefined;
                isOpen?: typeof import("../mod").isOpen | undefined;
                makePresence?: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                maxRequestsPerRateLimitTick?: number | undefined;
                previousSequenceNumber?: number | undefined;
                rateLimitResetInterval?: number | undefined;
                resume?: typeof import("../mod").resume | undefined;
                send?: typeof import("../mod").send | undefined;
                shutdown?: typeof import("../mod").shutdown | undefined;
                startHeartbeating?: typeof import("../mod").startHeartbeating | undefined;
                state?: import("../mod").ShardState | undefined;
                stopHeartbeating?: typeof import("../mod").stopHeartbeating | undefined;
                heart?: import("../mod").ShardHeart | undefined;
                bucket?: import("../../util/bucket").LeakyBucket | undefined;
                offlineSendQueue?: import("../mod").ShardSocketRequest[] | undefined;
            };
            gatewayConfig: import("../../mod").PickPartial<import("../mod").ShardGatewayConfig, "token">;
            shards: Map<number, {
                gatewayConfig: import("../mod").ShardGatewayConfig;
                heart: import("../mod").ShardHeart;
                id: number;
                maxRequestsPerRateLimitTick: number;
                previousSequenceNumber: number | null;
                rateLimitResetInterval: number;
                sessionId: string | undefined;
                socket: WebSocket | undefined;
                state: import("../mod").ShardState;
                totalShards: number;
                events: import("../mod").ShardEvents;
                calculateSafeRequests: () => number;
                close: (code: number, reason: string) => void;
                connect: () => Promise<void>;
                identify: () => Promise<void>;
                isOpen: () => boolean;
                makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                resume: () => Promise<void>;
                send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                shutdown: () => Promise<void>;
                bucket: import("../../util/bucket").LeakyBucket;
                handleClose: (close: CloseEvent) => Promise<void>;
                handleMessage: (message: MessageEvent<any>) => Promise<void>;
                requestIdentify: () => Promise<void>;
                offlineSendQueue: ((_?: unknown) => void)[];
                resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                startHeartbeating: (interval: number) => void;
                stopHeartbeating: () => void;
            }>;
            totalShards: number;
            identify: (shardId: number) => Promise<void>;
            kill: (shardId: number) => Promise<void>; /** Interval in milliseconds of when to check whether it's time to reshard.
             *
             * @default 28800000 (8 hours)
             */
            requestIdentify: (shardId: number) => Promise<void>;
        };
        spawnShardDelay: number;
        shardsPerWorker: number;
        totalWorkers: number;
        prepareBuckets: () => void;
        spawnShards: () => void;
        stop: (code: number, reason: string) => Promise<void>;
        tellWorkerToIdentify: (workerId: number, shardId: number, bucketId: number) => Promise<void>;
        debug: (text: import("./gatewayManager").GatewayDebugEvents, ...args: any[]) => unknown;
        calculateTotalShards: () => number;
        calculateWorkerId: (shardId: number) => number;
    }, workerId: number, shardId: number, bucketId: number) => Promise<void>;
};
export interface ActivateResharderOptions {
    /** Interval in milliseconds of when to check whether it's time to reshard.
     *
     * @default 28800000 (8 hours)
     */
    checkInterval?: number;
    /** Gateway manager which the resharder should be bound to. */
    gatewayManager: GatewayManager;
    /** Percentage at which resharding should occur.
     * @default 80
     */
    percentage?: number;
    /** Whether the resharder should automatically switch to LARGE BOT SHARDING when the bot is above 100K servers. */
    useOptimalLargeBotSharding?: boolean;
    /** Function which can be used to fetch the current gateway information of the bot.
     * This function is mainly used by the reshard checker.
     */
    getGatewayBot(): Promise<GatewayBot>;
    /** Function which is used to tell a Worker that it should identify a resharder Shard to the gateway and wait for further instructions.
     * The worker should **NOT** process any events coming from this Shard.
     */
    tellWorkerToPrepare(gatewayManager: GatewayManager, workerId: number, shardId: number, bucketId: number): Promise<void>;
}
/** Handler that by default will check to see if resharding should occur. Can be overridden if you have multiple servers and you want to communicate through redis pubsub or whatever you prefer. */
export declare function activate(resharder: Resharder): void;
export declare function reshard(resharder: Resharder, gatewayBot: GatewayBot): Promise<{
    buckets: Map<number, {
        workers: {
            id: number;
            queue: number[];
        }[];
        leak: import("../../util/bucket").LeakyBucket; /** The percentage at which resharding should occur.
        //       *
        //       * @default 80
        //       */
    }>;
    firstShardId: number;
    gatewayBot: import("../../mod").GatewayBot;
    lastShardId: number;
    manager: {
        createShardOptions: {
            /** Activate the resharder and delay the next reshard check. */
            events: {
                message: (shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }, payload: import("../../mod").DiscordGatewayPayload) => unknown;
                heartbeat?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                heartbeatAck?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                hello?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                invalidSession?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }, resumable: boolean) => unknown) | undefined;
                resuming?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                resumed?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                requestedReconnect?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                connecting?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                connected?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                disconnected?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                identifying?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
                identified?: ((shard: {
                    gatewayConfig: import("../mod").ShardGatewayConfig;
                    heart: import("../mod").ShardHeart;
                    id: number;
                    maxRequestsPerRateLimitTick: number;
                    previousSequenceNumber: number | null;
                    rateLimitResetInterval: number;
                    sessionId: string | undefined;
                    socket: WebSocket | undefined;
                    state: import("../mod").ShardState;
                    totalShards: number;
                    events: import("../mod").ShardEvents;
                    calculateSafeRequests: () => number;
                    close: (code: number, reason: string) => void;
                    connect: () => Promise<void>;
                    identify: () => Promise<void>;
                    isOpen: () => boolean;
                    makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
                    resume: () => Promise<void>;
                    send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
                    shutdown: () => Promise<void>;
                    bucket: import("../../util/bucket").LeakyBucket;
                    handleClose: (close: CloseEvent) => Promise<void>;
                    handleMessage: (message: MessageEvent<any>) => Promise<void>;
                    requestIdentify: () => Promise<void>;
                    offlineSendQueue: ((_?: unknown) => void)[];
                    resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
                    startHeartbeating: (interval: number) => void;
                    stopHeartbeating: () => void;
                }) => unknown) | undefined;
            };
            resolves?: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void> | undefined;
            calculateSafeRequests?: typeof import("../mod").calculateSafeRequests | undefined;
            close?: typeof import("../mod").close | undefined;
            connect?: typeof import("../mod").connect | undefined;
            handleClose?: typeof import("../mod").handleClose | undefined;
            handleMessage?: typeof import("../mod").handleMessage | undefined;
            identify?: typeof import("../mod").identify | undefined;
            isOpen?: typeof import("../mod").isOpen | undefined;
            makePresence?: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
            maxRequestsPerRateLimitTick?: number | undefined;
            previousSequenceNumber?: number | undefined;
            rateLimitResetInterval?: number | undefined;
            resume?: typeof import("../mod").resume | undefined;
            send?: typeof import("../mod").send | undefined;
            shutdown?: typeof import("../mod").shutdown | undefined;
            startHeartbeating?: typeof import("../mod").startHeartbeating | undefined;
            state?: import("../mod").ShardState | undefined;
            stopHeartbeating?: typeof import("../mod").stopHeartbeating | undefined;
            heart?: import("../mod").ShardHeart | undefined;
            bucket?: import("../../util/bucket").LeakyBucket | undefined;
            offlineSendQueue?: import("../mod").ShardSocketRequest[] | undefined;
        };
        gatewayConfig: import("../../mod").PickPartial<import("../mod").ShardGatewayConfig, "token">;
        shards: Map<number, {
            gatewayConfig: import("../mod").ShardGatewayConfig;
            heart: import("../mod").ShardHeart;
            id: number;
            maxRequestsPerRateLimitTick: number;
            previousSequenceNumber: number | null;
            rateLimitResetInterval: number;
            sessionId: string | undefined;
            socket: WebSocket | undefined;
            state: import("../mod").ShardState;
            totalShards: number;
            events: import("../mod").ShardEvents;
            calculateSafeRequests: () => number;
            close: (code: number, reason: string) => void;
            connect: () => Promise<void>;
            identify: () => Promise<void>;
            isOpen: () => boolean;
            makePresence: ((shardId: number) => import("../../mod").DiscordStatusUpdate | Promise<import("../../mod").DiscordStatusUpdate>) | undefined;
            resume: () => Promise<void>;
            send: (message: import("../mod").ShardSocketRequest, highPriority?: boolean) => Promise<void>;
            shutdown: () => Promise<void>;
            bucket: import("../../util/bucket").LeakyBucket;
            handleClose: (close: CloseEvent) => Promise<void>;
            handleMessage: (message: MessageEvent<any>) => Promise<void>;
            requestIdentify: () => Promise<void>;
            offlineSendQueue: ((_?: unknown) => void)[];
            resolves: Map<"READY" | "RESUMED" | "INVALID_SESSION", (payload: import("../../mod").DiscordGatewayPayload) => void>;
            startHeartbeating: (interval: number) => void;
            stopHeartbeating: () => void;
        }>;
        totalShards: number;
        identify: (shardId: number) => Promise<void>;
        kill: (shardId: number) => Promise<void>; /** Interval in milliseconds of when to check whether it's time to reshard.
         *
         * @default 28800000 (8 hours)
         */
        requestIdentify: (shardId: number) => Promise<void>;
    };
    spawnShardDelay: number;
    shardsPerWorker: number;
    totalWorkers: number;
    prepareBuckets: () => void;
    spawnShards: () => void;
    stop: (code: number, reason: string) => Promise<void>;
    tellWorkerToIdentify: (workerId: number, shardId: number, bucketId: number) => Promise<void>;
    debug: (text: import("./gatewayManager").GatewayDebugEvents, ...args: any[]) => unknown;
    calculateTotalShards: () => number;
    calculateWorkerId: (shardId: number) => number;
}>;
/** Handler that by default will check all new shards are online in the new gateway. The handler can be overridden if you have multiple servers to communicate through redis pubsub or whatever you prefer. */
export declare function resharderIsPending(gateway: GatewayManager, oldGateway: GatewayManager): Promise<boolean>;
/** Handler that by default closes all shards in the old gateway. Can be overridden if you have multiple servers and you want to communicate through redis pubsub or whatever you prefer. */
export declare function resharderCloseOldShards(oldGateway: GatewayManager): Promise<void>;
/** Handler that by default will save the new shard id for each guild this becomes ready in new gateway. This can be overridden to save the shard ids in a redis cache layer or whatever you prefer. These ids will be used later to update all guilds. */
export declare function markNewGuildShardId(guildIds: bigint[], shardId: number): Promise<void>;
/** Handler that by default does not do anything since by default the library will not cache. */
export declare function reshardingEditGuildShardIds(): Promise<void>;
