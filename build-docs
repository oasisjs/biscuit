#!/usr/bin/env node

// Node imports
var fs = require('fs');
var path = require('path');
var process = require('process');
var child_process = require('child_process');

// Path with the docs.json file generated with `deno doc --json mod.ts > docs.json`
var docsPath = path.join(__dirname, '/docs.json');
var mainBranchURL = 'https://github.com/oasisjs/biscuit/tree/main';

/**
 * Execute a new subprocess with the given command.
 * @param {string} cmd - The command to run
 * @return {void}
*/
function exec(cmd) {
    child_process.execSync(cmd, {stdio: 'inherit', cwd: __dirname});
}

/**
 * Returns a new javascript object with the docs.json file.
 * @returns {[]any}
 */
function getDocs() {
    if (!fs.existsSync(docsPath)) {
        throw new Error('The docs.json file does not exist. Use: deno doc --json mod.ts > docs.json');
    }

    var res = fs.readFileSync(docsPath, { encoding: 'utf-8' }).toString().trim().replaceAll(/[^A-Za-z0-9\"\:\{\}\[\]\.\,\/\\\_\-]/g, '');
    return JSON.parse(res);
}

/**
 * Get the file location at the main branch of the repository.
 * @param {{ filename: string, line: number, col: number }} location - The filename to check
 * @returns {string}
*/
function getLocationURL(location) {
    var filename = location.filename;
    var start = filename.indexOf('/packages/');
    var componentPath = filename.slice(start, filename.length);
    var lineAndCol = `#L${location.line}:${location.col}`;

    return mainBranchURL + componentPath + lineAndCol;
}

/**
 * 
 * @param {any} docsElement
 * @returns {{expression: string, kind: string, name: string, url: string} | null}
 */
function loadComponent(docsElement) {
    if (
        docsElement.declarationKind != 'export' ||
        docsElement.name == "default" ||
        docsElement.kind == 'import'
    ) {
        return null;
    }

    var url = getLocationURL(docsElement.location);
    var exp = parseExpression(docsElement);
    return {
        expression: exp,
        kind: docsElement.kind,
        name: docsElement.name,
        url: url
    };
}

/**
 * Parse the docs element to get the expression.
 * @param {any} docsElement 
 * @returns {string}
*/
function parseExpression(docsElement) {
    var loaded = '';

    switch (docsElement.kind) {
        case 'variable':
            var variableDef = docsElement.variableDef;
            var kind = variableDef.kind;

            var type = "";
            if (variableDef.tsType) {
                switch (variableDef.tsType.kind) {
                    case 'literal':
                        type = variableDef.tsType.literal.kind;
                        break;
                    case 'typeRef':
                        type = variableDef.tsType.typeRef.typeName;
                        break;
                    default:
                        type = variableDef.tsType.repr;
                }
            } else {
                return ''
            }

            // Ex: var foo: string = 'bar'
            var component = `${kind} ${docsElement.name}: ${type}`;
            if (component.indexOf('undefined') != -1) {
                return '';
            }
            
            loaded += component;
        break;

        case 'interface':
            // interface definition
            var interfaceDef = docsElement.interfaceDef; 
            
            // creating the interface
            loaded += `interface ${docsElement.name}`;
            
            // the interface extends another type
            if (interfaceDef.extends && interfaceDef.extends.length > 0) {
                loaded += ` extends ${parseExtendsParam(interfaceDef)}`;
            }                
        break;

        case 'enum':
            loaded += `enum ${docsElement.name}`;
        break;

        case 'class':
            if (docsElement.classDef?.isAbstract) {
                loaded += 'abstract ';
            }

            loaded += `class ${docsElement.name}`;

            if (docsElement.classDef?.constructors && docsElement.classDef?.constructors.length > 0) {
                var classDef = docsElement.classDef;
                loaded += '(';

                for (var i = 0; i < classDef.constructors.length; i++) {
                    var params = classDef.constructors[i].params;
                    var args = [];

                    if (params && params.length > 0) {
                        for (var j = 0; j < params.length; j++) {
                            if (params[j].kind && params[j].kind === 'assign') {
                                // TODO: parse constructor params
                                args.push('');
                            }
                        }
                    }

                    loaded += `${args.join(', ')}`;
                }

                loaded += ')';
            }
        break;

        // TODO: case 'typeAlias' and parse type alias

        default:
            loaded += '';
    }

    return loaded;
}

/**
 * 
 * @param {any[]} definition 
 * @returns {string}
*/
function parseExtendsParam(definition)  {
    var loaded = '';

    /** @type {any[]} */
    var ext = definition.extends;
    for (var i = 0; i < ext.length; i++) {
        // Current type extended
        loaded += `${ext[i].repr}`;

        // If type receives parameters
        if (ext[i].typeRef) {
            if (ext[i].typeRef.typeParams && ext[i].typeRef.typeParams.length > 0) {
                /** @type {any[]} */
                var typeParams = ext[i].typeRef.typeParams;
                /** @type {any[]} */
                var params = [];
                /** @type {boolean} */
                var isUnion = false;

                for (var j = 0; j < typeParams.length; j++) {
                    if (typeParams[j].kind === "typeRef") {
                        params.push(typeParams[j].repr);
                    }

                    if (typeParams[j].kind === "union") {
                        isUnion = true;
                        typeParams[j].union.forEach(un => {
                            params.push(`"${un.repr}"`);
                        })
                    }
                }
            }
        }

        if (isUnion) {
            var first = params.shift();
            loaded += `<${first}, ${params.join(' | ')}>`;
            isUnion = false;
        } else {
            if (params) {
                loaded += `<${params}>`;
            }
        }

        // If it's not the last type extended
        // ex: interface Foo extends Bar<type>, Baz<type>
        if (i < ext.length - 1) {
            loaded += `, `;
        }
    }

    return loaded;
}

/**
 * 
 * @param {any[]} docs - The docs.json file
 * @returns {{expression: string, kind: string, name: string, url: string}[]}
*/
function loadAllComponents(docs) {
    var loaded = [];

    docs.forEach(element => {
        var el = loadComponent(element);
        if (el !== null) {
            loaded.push(el);
        }
    })

    return loaded;
}

try {
    var docs = getDocs();
    var load = loadAllComponents(docs);

    console.log(load)
} catch(err) {
    throw new Error(err);
}